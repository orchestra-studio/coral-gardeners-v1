---
phase: 01-foundation-and-deployment-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - front-end/.env.production
  - front-end/.env.example
autonomous: false
user_setup:
  - service: render
    why: "Backend hosting with PostgreSQL database"
    env_vars:
      - name: FRONTEND_URL
        source: "Set after Vercel deployment provides URL"
      - name: CORS_ORIGIN
        source: "Same as FRONTEND_URL"
      - name: DEEPSEEK_API_KEY
        source: "DeepSeek Dashboard -> API Keys (or whichever LLM provider)"
    dashboard_config:
      - task: "Enable PgBouncer connection pooling on the database"
        location: "Render Dashboard -> Database -> Info -> Connection Pooling -> Enable"
  - service: vercel
    why: "Frontend hosting"
    env_vars:
      - name: NEXT_PUBLIC_API_BASE_URL
        source: "Render backend URL + /api (e.g., https://cg-dashboard-backend.onrender.com/api)"
      - name: NEXT_PUBLIC_WEBSOCKET_BASE_URL
        source: "Render backend URL (e.g., https://cg-dashboard-backend.onrender.com)"

must_haves:
  truths:
    - "Backend API responds at Render URL (GET /api/health returns 200)"
    - "Frontend loads from Vercel URL without errors"
    - "Frontend can reach backend API (no CORS errors in browser console)"
    - "Environment variables are correctly separated (NEXT_PUBLIC_ for frontend, server vars for backend)"
    - "PostgreSQL database accepts connections with PgBouncer pooling enabled"
  artifacts:
    - path: "front-end/.env.production"
      provides: "Production environment variables for Vercel"
      min_lines: 3
    - path: "front-end/.env.example"
      provides: "Updated env example with WebSocket URL"
      min_lines: 5
  key_links:
    - from: "Vercel frontend"
      to: "Render backend /api/health"
      via: "NEXT_PUBLIC_API_BASE_URL fetch"
      pattern: "NEXT_PUBLIC_API_BASE_URL"
    - from: "Vercel frontend"
      to: "Render backend WebSocket"
      via: "NEXT_PUBLIC_WEBSOCKET_BASE_URL socket.io connection"
      pattern: "NEXT_PUBLIC_WEBSOCKET_BASE_URL"
    - from: "Render backend"
      to: "Render PostgreSQL"
      via: "DATABASE_URL with PgBouncer"
      pattern: "DATABASE_URL"
---

<objective>
Deploy the backend to Render and frontend to Vercel, configure environment variables, enable PgBouncer connection pooling, and verify end-to-end connectivity.

Purpose: Get the application live in production with proper cross-origin communication between Vercel frontend and Render backend, PostgreSQL database with connection pooling, and all environment variables correctly configured.

Output: Live, accessible application at Render and Vercel URLs with health check passing and CORS working.
</objective>

<execution_context>
@/Users/ludovicgoutel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ludovicgoutel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-deployment-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-and-deployment-infrastructure/01-01-SUMMARY.md
@render.yaml
@front-end/.env.example
@back-end/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deploy backend to Render and frontend to Vercel</name>
  <files>
    front-end/.env.production
    front-end/.env.example
  </files>
  <action>
1. **Pre-deployment: Ensure code is in a Git repository.**
   - If not already a git repo, initialize one and push to GitHub (required for both Render and Vercel).
   - Both Render and Vercel deploy from Git repositories.

2. **Deploy backend to Render:**
   - Option A (preferred): Use render.yaml Blueprint. Go to Render Dashboard -> New -> Blueprint -> connect GitHub repo. Render reads render.yaml and creates the web service + PostgreSQL database automatically.
   - Option B (manual): Use Render Dashboard -> New Web Service -> connect repo -> set root directory to `back-end`, build command `yarn install && yarn build`, start command `yarn start:prod`, health check path `/api/health`.
   - After creation, note the backend URL (e.g., `https://cg-dashboard-backend.onrender.com`).

3. **Configure Render environment variables** (in Render Dashboard -> Web Service -> Environment):
   - `NODE_ENV=production`
   - `DB_TYPE=postgres`
   - `DATABASE_URL` (auto-populated if using Blueprint, or copy from Database -> Info -> External Connection String)
   - `JWT_SECRET` (auto-generated if using Blueprint, or set a strong random value)
   - `JWT_EXPIRATION=7d`
   - `PORT=10000`
   - `FRONTEND_URL` (set AFTER Vercel deploy, placeholder for now)
   - `CORS_ORIGIN` (set AFTER Vercel deploy, placeholder for now)
   - LLM API keys as needed (DEEPSEEK_API_KEY, GOOGLE_API_KEY, etc.)

4. **Enable PgBouncer connection pooling:**
   - Render Dashboard -> Database (cg-dashboard-db) -> Info tab -> scroll to "Connection Pooling" -> click "Enable"
   - After enabling, update DATABASE_URL in the web service to use the **pooled connection string** (different port, typically 6543 vs 5432).

5. **Create `front-end/.env.production`** with Render backend URL:
   ```
   NEXT_PUBLIC_API_BASE_URL=https://YOUR-RENDER-BACKEND-URL.onrender.com/api
   NEXT_PUBLIC_WEBSOCKET_BASE_URL=https://YOUR-RENDER-BACKEND-URL.onrender.com
   ```
   Replace YOUR-RENDER-BACKEND-URL with the actual Render service URL.

6. **Deploy frontend to Vercel:**
   - Use Vercel CLI: `cd front-end && npx vercel --yes` or connect via Vercel Dashboard -> New Project -> import GitHub repo.
   - Set root directory to `front-end` if deploying from monorepo root.
   - Add environment variables in Vercel Dashboard -> Project Settings -> Environment Variables:
     - `NEXT_PUBLIC_API_BASE_URL=https://YOUR-RENDER-BACKEND-URL.onrender.com/api`
     - `NEXT_PUBLIC_WEBSOCKET_BASE_URL=https://YOUR-RENDER-BACKEND-URL.onrender.com`
   - Note the Vercel URL (e.g., `https://cg-dashboard.vercel.app`).

7. **Update Render backend with Vercel URL:**
   - Go back to Render Dashboard -> Web Service -> Environment
   - Set `FRONTEND_URL=https://YOUR-VERCEL-URL.vercel.app`
   - Set `CORS_ORIGIN=https://YOUR-VERCEL-URL.vercel.app`
   - This triggers a redeploy on Render with correct CORS origins.

8. **Trigger Vercel redeploy** if env vars were added after first deploy (NEXT_PUBLIC_ vars are build-time):
   - Vercel Dashboard -> Deployments -> Redeploy (or push a commit).
  </action>
  <verify>
   Backend health check: `curl -s https://YOUR-RENDER-BACKEND-URL.onrender.com/api/health` returns 200 with `{"status":"ok","info":{"database":{"status":"up"}}}`.
   Frontend loads: Visit Vercel URL in browser, page renders without blank screen.
  </verify>
  <done>
   Backend is live on Render with PostgreSQL + PgBouncer. Frontend is live on Vercel. Both services are accessible at their URLs.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end connectivity</name>
  <what-built>
    Full production deployment: NestJS backend on Render with PostgreSQL database and PgBouncer connection pooling, Next.js frontend on Vercel with environment variables pointing to backend.
  </what-built>
  <how-to-verify>
    1. Open Render backend health check URL in browser: `https://YOUR-RENDER-URL.onrender.com/api/health`
       - Expected: JSON response with `{"status":"ok","info":{"database":{"status":"up"},"memory_heap":{"status":"up"}}}`
    2. Open Vercel frontend URL in browser: `https://YOUR-VERCEL-URL.vercel.app`
       - Expected: Dashboard loads, login page or main page appears (no blank screen)
    3. Open browser DevTools (F12) -> Console tab while on Vercel frontend
       - Expected: No CORS errors (no "Access-Control-Allow-Origin" errors)
    4. Open browser DevTools -> Network tab, look for API requests to Render backend
       - Expected: Requests succeed (200 status), not blocked by CORS
    5. Verify environment variables:
       - In browser DevTools Console, check if API calls go to the correct Render URL (not localhost:3001)
    6. (Optional) Test WebSocket: If login page is accessible, try logging in to verify Socket.IO connection
       - Expected: No WebSocket connection errors in console
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues encountered (CORS errors, blank page, health check failures, etc.)</resume-signal>
</task>

</tasks>

<verification>
1. `curl -s RENDER_URL/api/health` returns HTTP 200 with database status "up"
2. Vercel URL loads in browser without blank screen
3. Browser console shows no CORS errors when frontend communicates with backend
4. Render Dashboard shows PostgreSQL connection pooling enabled
5. Render environment has FRONTEND_URL and CORS_ORIGIN set to Vercel URL
6. Vercel environment has NEXT_PUBLIC_API_BASE_URL and NEXT_PUBLIC_WEBSOCKET_BASE_URL set to Render URL
</verification>

<success_criteria>
- Backend API accessible at Render URL and responds to health checks with database "up"
- Frontend loads from Vercel URL and can connect to backend API
- PostgreSQL database accepts connections with PgBouncer connection pooling enabled
- CORS allows Vercel frontend to communicate with Render backend (no browser CORS errors)
- Environment variables properly separated (NEXT_PUBLIC_ prefix works for frontend, server vars for backend)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-deployment-infrastructure/01-02-SUMMARY.md`
</output>
