---
phase: 01-foundation-and-deployment-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - back-end/src/app.module.ts
  - back-end/src/main.ts
  - back-end/src/modules/auth/auth.gateway.ts
  - back-end/src/health/health.module.ts
  - back-end/src/health/health.controller.ts
  - back-end/package.json
  - back-end/.env.example
  - render.yaml
autonomous: true

must_haves:
  truths:
    - "Backend app.module.ts has a DB_TYPE=postgres branch with SSL, connection pooling (max 10), and synchronize:false"
    - "GET /api/health returns 200 with database ping status"
    - "CORS in main.ts uses explicit FRONTEND_URL origin, not wildcard, with credentials:true"
    - "Socket.IO gateway CORS reads FRONTEND_URL from env with credentials:true"
    - "render.yaml defines web service and PostgreSQL database with PgBouncer pooling"
  artifacts:
    - path: "back-end/src/health/health.module.ts"
      provides: "Health check module"
      min_lines: 10
    - path: "back-end/src/health/health.controller.ts"
      provides: "Health check controller with DB ping"
      min_lines: 15
    - path: "render.yaml"
      provides: "Render infrastructure-as-code blueprint"
      min_lines: 20
  key_links:
    - from: "back-end/src/health/health.module.ts"
      to: "back-end/src/app.module.ts"
      via: "HealthModule imported in AppModule"
      pattern: "HealthModule"
    - from: "back-end/src/app.module.ts"
      to: "DATABASE_URL env var"
      via: "TypeORM postgres config branch"
      pattern: "DATABASE_URL"
    - from: "back-end/src/main.ts"
      to: "FRONTEND_URL env var"
      via: "CORS origin config"
      pattern: "FRONTEND_URL"
---

<objective>
Prepare the NestJS backend for production deployment on Render with PostgreSQL support, health checks, and proper CORS configuration.

Purpose: The backend currently only supports SQLite and MySQL. We need to add PostgreSQL support with connection pooling, a health check endpoint for Render monitoring, explicit CORS origins for cross-domain security, and a render.yaml blueprint for infrastructure-as-code deployment.

Output: Production-ready backend code with health endpoint, PostgreSQL branch in database config, updated CORS, and Render deployment blueprint.
</objective>

<execution_context>
@/Users/ludovicgoutel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ludovicgoutel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-deployment-infrastructure/01-RESEARCH.md
@back-end/src/app.module.ts
@back-end/src/main.ts
@back-end/src/modules/auth/auth.gateway.ts
@back-end/package.json
@back-end/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PostgreSQL support, health checks, and install dependencies</name>
  <files>
    back-end/package.json
    back-end/src/app.module.ts
    back-end/src/health/health.module.ts
    back-end/src/health/health.controller.ts
  </files>
  <action>
1. Install production dependencies in back-end/:
   ```bash
   cd back-end && yarn add @nestjs/terminus pg @nestjs/axios
   ```

2. Add PostgreSQL branch to TypeORM config in `back-end/src/app.module.ts`:
   - Keep existing `mysql` and `sqlite` branches intact
   - Add new `postgres` branch BEFORE the mysql check:
     ```typescript
     if (dbType === 'postgres') {
         const isProduction = configService.get('NODE_ENV') === 'production';
         return {
             ...baseConfig,
             type: 'postgres' as const,
             url: configService.get<string>('DATABASE_URL'),
             ssl: isProduction ? { rejectUnauthorized: false } : false,
             synchronize: false, // Use migrations in production
             logging: !isProduction,
             extra: {
                 max: 10,
                 connectionTimeoutMillis: 3000,
                 idleTimeoutMillis: 30000,
             },
         };
     }
     ```
   - IMPORTANT: The `synchronize` in baseConfig uses `NODE_ENV === 'development'` check which is fine for sqlite/mysql. The postgres branch explicitly sets `synchronize: false` to override.

3. Create `back-end/src/health/health.module.ts`:
   ```typescript
   import { Module } from '@nestjs/common';
   import { TerminusModule } from '@nestjs/terminus';
   import { HttpModule } from '@nestjs/axios';
   import { HealthController } from './health.controller';

   @Module({
       imports: [TerminusModule, HttpModule],
       controllers: [HealthController],
   })
   export class HealthModule {}
   ```

4. Create `back-end/src/health/health.controller.ts`:
   ```typescript
   import { Controller, Get } from '@nestjs/common';
   import {
       HealthCheck,
       HealthCheckService,
       TypeOrmHealthIndicator,
       MemoryHealthIndicator,
   } from '@nestjs/terminus';

   @Controller('health')
   export class HealthController {
       constructor(
           private health: HealthCheckService,
           private db: TypeOrmHealthIndicator,
           private memory: MemoryHealthIndicator,
       ) {}

       @Get()
       @HealthCheck()
       check() {
           return this.health.check([
               () => this.db.pingCheck('database', { timeout: 3000 }),
               () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),
           ]);
       }
   }
   ```

5. Import HealthModule in `back-end/src/app.module.ts`:
   - Add `import { HealthModule } from './health/health.module';`
   - Add `HealthModule` to the imports array (after McpModule)
  </action>
  <verify>
   Run `cd back-end && yarn install` succeeds.
   Verify `pg` and `@nestjs/terminus` appear in node_modules.
   Run `cd back-end && yarn build` compiles without errors.
  </verify>
  <done>
   Backend compiles with PostgreSQL driver, health check module, and all new dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CORS configuration and create Render blueprint</name>
  <files>
    back-end/src/main.ts
    back-end/src/modules/auth/auth.gateway.ts
    back-end/.env.example
    render.yaml
  </files>
  <action>
1. Update CORS in `back-end/src/main.ts`:
   - Replace the existing `app.enableCors()` block with:
     ```typescript
     app.enableCors({
         origin: configService.get('CORS_ORIGIN')
             ? configService.get('CORS_ORIGIN').split(',').map(s => s.trim())
             : ['http://localhost:3000'],
         methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
         credentials: true,
         allowedHeaders: 'Content-Type,Accept,Authorization',
     });
     ```
   - This supports comma-separated origins for flexibility (e.g., production + preview URLs).

2. Update Socket.IO CORS in `back-end/src/modules/auth/auth.gateway.ts`:
   - The existing code already reads `process.env.FRONTEND_URL`. Verify it has `credentials: true`.
   - Add `transports: ['websocket', 'polling']` to the gateway options for polling fallback.
   - The @WebSocketGateway decorator should look like:
     ```typescript
     @WebSocketGateway({
         cors: {
             origin: process.env.FRONTEND_URL || 'http://localhost:3000',
             credentials: true,
         },
         namespace: 'auth',
         transports: ['websocket', 'polling'],
     })
     ```

3. Update `back-end/.env.example` to add production vars:
   - Add these new entries (keep all existing entries):
     ```
     # Frontend URL (for CORS and WebSocket)
     FRONTEND_URL=http://localhost:3000

     # PostgreSQL Configuration (used when DB_TYPE=postgres)
     # DATABASE_URL=postgresql://user:password@host:5432/database
     ```

4. Create `render.yaml` in project root (NOT inside back-end/):
   ```yaml
   services:
     - type: web
       name: cg-dashboard-backend
       runtime: node
       region: oregon
       plan: free
       rootDir: back-end
       buildCommand: yarn install && yarn build
       startCommand: yarn start:prod
       healthCheckPath: /api/health
       envVars:
         - key: NODE_ENV
           value: production
         - key: DB_TYPE
           value: postgres
         - key: DATABASE_URL
           fromDatabase:
             name: cg-dashboard-db
             property: connectionString
         - key: FRONTEND_URL
           sync: false
         - key: CORS_ORIGIN
           sync: false
         - key: JWT_SECRET
           generateValue: true
         - key: JWT_EXPIRATION
           value: 7d
         - key: PORT
           value: 10000

   databases:
     - name: cg-dashboard-db
       databaseName: cg_dashboard
       user: cg_dashboard_user
       plan: free
       region: oregon
   ```
   Note: PgBouncer connection pooling is enabled via the Render dashboard after database creation (not configurable in render.yaml). The DATABASE_URL from Render will automatically point to the pooled connection when enabled.
  </action>
  <verify>
   Run `cd back-end && yarn build` still compiles.
   Verify render.yaml exists at project root and is valid YAML (use `python3 -c "import yaml; yaml.safe_load(open('render.yaml'))"` or similar).
   Verify .env.example contains DATABASE_URL and FRONTEND_URL entries.
  </verify>
  <done>
   CORS uses explicit origins (not wildcard) with credentials support. Socket.IO gateway has polling fallback. render.yaml defines backend service and PostgreSQL database. .env.example documents all production environment variables.
  </done>
</task>

</tasks>

<verification>
1. `cd back-end && yarn build` completes without errors
2. `grep -q "postgres" back-end/src/app.module.ts` confirms PostgreSQL branch exists
3. `grep -q "HealthModule" back-end/src/app.module.ts` confirms health module imported
4. Health controller file exists at `back-end/src/health/health.controller.ts`
5. `render.yaml` exists at project root
6. `grep -q "FRONTEND_URL" back-end/.env.example` confirms env var documented
7. CORS in main.ts does NOT contain `origin: '*'` for production
</verification>

<success_criteria>
- Backend builds cleanly with PostgreSQL driver and health check module
- Health endpoint at /api/health will return 200 with DB status (testable after deployment)
- CORS configured for explicit origins with credentials support
- render.yaml provides one-click Render deployment blueprint
- All production environment variables documented in .env.example
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-deployment-infrastructure/01-01-SUMMARY.md`
</output>
